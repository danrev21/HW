
При многоэтапных сборках вы используете несколько операторов FROM в своем файле Dockerfile. Каждая инструкция FROM может использовать другую базу, и каждая из них начинает новый этап сборки.
Вы можете выборочно копировать артефакты с одного этапа на другой, оставляя в конечном изображении все ненужное. 
Следующий Dockerfile состоит из двух отдельных этапов: один для создания двоичного файла, а другой — для копирования двоичного файла.

# Stage 1: Build Stage
FROM golang:1.21 as builder

# Set the working directory inside the container
WORKDIR /src

# Copy the main.go file into the working directory
COPY main.go ./

# Build the Go application and create an executable named 'hello' in the /bin directory
RUN go build -o /bin/hello ./main.go

# Stage 2: Final Stage
FROM scratch

# Copy the 'hello' executable from the builder stage into the /bin directory of the new image
COPY --from=builder /bin/hello /bin/hello

# Set the default command to run when the container starts
CMD ["/bin/hello"]

Stage 1 (Builder Stage):
В качестве базового образа для сборки используется официальный образ Golang версии 1.21.
Устанавливает рабочий каталог /src внутри контейнера.
Копирует файл main.go с хоста в рабочий каталог.
Собирает приложение Go и создает исполняемый файл с именем hello в каталоге /bin.

Stage 2 (Final Stage):
Использует scratch base image, которое представляет собой empty image, для создания изображения минимального размера.
Копирует исполняемый файл «hello» со стадии сборки (/bin/hello) в каталог /bin нового образа.

CMD Directive:
Устанавливает команду по умолчанию, которая будет запускаться при запуске контейнера, определяя выполнение исполняемого файла «/bin/hello».

При этом Dockerfile используется подход многоэтапной сборки для создания облегченного образа, содержащего только необходимые артефакты для запуска приложения Go. Окончательное изображение основано на минимальном рабочем изображении, что минимизирует размер контейнера.

Заключение:
С помощью многоэтапного файла Docker вы можете разделить процедуры сборки и упаковки, чтобы никакие сценарии, инструменты и платформы, связанные со сборкой, не попадали в результирующий пакет приложения.

Приняв многоэтапный Dockerfile, разработчики получают мощный инструмент для повышения эффективности, безопасности и удобства обслуживания контейнерных приложений. Эта методология соответствует передовым практикам контейнеризации, способствуя созданию экономичных и оптимизированных образов, обеспечивающих превосходную производительность и эффективное использование ресурсов.

Документация:
https://docs.docker.com/build/building/multi-stage/
https://medium.com/@tonistiigi/advanced-multi-stage-build-patterns-6f741b852fae


# FROM scratch
This image is most useful in the context of building base images (such as debian and busybox) or super minimal images (that contain only a single binary and whatever it requires, such as hello-world).

Начиная с Docker 1.5.0 (в частности, docker/docker#8827), FROM scratch является неактивным в файле Dockerfile и не создает дополнительный layer в вашем образе (поэтому ранее двухслойное изображение станет однослойным).


Использование scratch «образа» сигнализирует процессу сборки о том, что вы хотите, чтобы следующая команда в файле Dockerfile была первым слоем файловой системы в вашем образе.
While scratch appears in Docker’s repository on the hub, you can’t pull it, run it, or tag any image with the name scratch. Instead, you can refer to it in your Dockerfile. For example, to create a minimal container using scratch:

FROM scratch
COPY hello /
CMD ["/hello"]

# ВЫВОДЫ:
Использование многоэтапного файла Dockerfile позволяет разделить процедуры сборки и упаковки, гарантируя, что никакие посторонние сценарии, инструменты или платформы, связанные со сборкой, не станут частью окончательного пакета приложения. Этот подход упрощает и упрощает процесс контейнеризации, обеспечивая ряд преимуществ:

# Изоляция среды сборки:
Начальный этап сборки позволяет включать инструменты сборки, зависимости и сценарии, необходимые для компиляции и создания приложения. Этот этап остается изолированным, что предотвращает попадание ненужных компонентов в конечный контейнер.

# Минимизация размера контейнера:
Последующие этапы, часто называемые этапами «производства», включают только основные артефакты и двоичные файлы, созданные в процессе сборки. Ненужные файлы и инструменты исключены, что приводит к значительно меньшему и более оптимизированному размеру контейнера.

# Повышенная безопасность:
Исключение артефактов, связанных со сборкой, из окончательного образа снижает потенциальные риски безопасности, связанные с ненужными инструментами или сценариями. Эта практика соответствует принципу наименьших привилегий, сводя к минимуму поверхность атаки контейнерного приложения.

# Эффективные конвейеры CI/CD:
Многоэтапные сборки способствуют повышению эффективности конвейеров непрерывной интеграции/непрерывного развертывания (CI/CD). Разделение компонентов среды сборки и среды выполнения позволяет ускорить сборку и развертывание образов, сокращая общее время выполнения конвейера.

# Улучшенное управление жизненным циклом изображений:
Четкая изоляция между этапами сборки и выполнения упрощает управление жизненным циклом образа. Разработчики могут сосредоточиться на доработке кода приложения и зависимостей, не беспокоясь о случайном включении несущественных элементов в окончательный образ.

# Адаптивность к различным средам:
Многоэтапные сборки позволяют создавать специализированные образы, адаптированные для различных сред, таких как разработка, тестирование и производство. На каждом этапе содержимое образа оптимизируется для своей конкретной роли, повышая адаптируемость к различным сценариям развертывания.
Приняв многоэтапный файл Dockerfile, разработчики получают мощный инструмент для повышения эффективности, безопасности и удобства обслуживания контейнерных приложений. Эта методология соответствует передовым практикам контейнеризации, способствуя созданию экономичных и оптимизированных образов, обеспечивающих превосходную производительность и эффективное использование ресурсов.

