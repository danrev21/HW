=============================================================================================================
Запуск контейнеров как в автономном, так и в интерактивном режимах.
Публикация открытых портов как для случайных, так и для конкретных портов для повышения доступности.
Выполнение команд внутри запущенных контейнеров для взаимодействия с их средой.
Эффективная остановка и удаление контейнеров, управление их жизненным циклом.
Настройка дополнительных параметров, включая настройки пользователя и группы, указание рабочих каталогов и определение переменных среды.
Получение информации о потенциальных ошибках в контейнерах Docker с помощью команды docker logs для всестороннего исследования ошибок. Это всестороннее исследование обеспечит прочную основу для эффективных методов контейнеризации.

 
# Идентификатор пользователя/идентификатор группы/идентификатор вторичной группы
Обычно основной процесс в контейнере выполняется под root:rootпользователем (если он не изменен в Dockerfile директивой USER).
Обычно мы имеем дело со сторонними (официальными изображениями) изображениями и всегда должны это учитывать. Когда мы создаем контейнеры с помощью docker run команды, мы также можем переопределить эти настройки.

Просто пример, когда мы запускаем conainer и ожидаем, что он создаст несколько файлов, сохранив их в папке, смонтированной с хоста, внутри контейнера - необходимо убедиться, что права доступа к файлам и/или право собственности верны:

notroot@docker-host:~$ ls -la
total 8
drwxr-xr-x 2 notroot notroot 4096 May 19 20:14 .
drwxr-xr-x 1 root    root    4096 May 19 20:14 ..

notroot@docker-host:~$ id
uid=1000(notroot) gid=1000(notroot) groups=1000(notroot),999(docker)

notroot@docker-host:~$ touch $(pwd)/file1
notroot@docker-host:~$ docker run --rm -v $(pwd):$(pwd) alpine touch $(pwd)/file2
notroot@docker-host:~$ ls -la
total 8
drwxr-xr-x 2 notroot notroot 4096 May 19 20:16 .
drwxr-xr-x 1 root    root    4096 May 19 20:14 ..
-rw-r--r-- 1 notroot notroot    0 May 19 20:16 file1
-rw-r--r-- 1 root    root       0 May 19 20:17 file2
Для изменения настроек пользователя рассмотрите следующие варианты (до docker run):

--user string- Имя пользователя или UID (формат: <name|uid>[:<group|gid>])
--group-add list- Добавить дополнительные группы для присоединения

# Рабочий каталог
По умолчанию установлено значение /(если оно не настроено в Dockerfile директивой WORKDIR). Это рабочий каталог основного процесса, и (скорее всего) основной процесс использует файлы, расположенные внутри этой папки. Считайте это так cd $WORKDIR && to run the app:

...
WORKDIR /opt/tomcat
CMD ./bin/catalina.sh run
Не то чтобы нам приходилось его постоянно менять, но иногда это может нам помочь, особенно если мы имеем дело с официальными изображениями.

Чтобы запустить контейнер с другим WORKDIR, чем он установлен в образе докера, рассмотрите возможность использования следующего варианта:

-w, --workdir string- Рабочий каталог внутри контейнера
$ docker run --rm alpine pwd
/

$ docker run --rm -w /Directory alpine pwd
/Directory

# Пользовательские переменные среды
Один из 12-факторных принципов проектирования гласит: «Храните конфигурацию в окружающей среде» . На самом деле это наиболее распространенный подход к предоставлению пользовательских настроек для современных микросервисов (обычно для приложений без отслеживания состояния).

Чтобы запустить контейнер с пользовательскими переменными среды, используйте следующие параметры:

-e, --env list- Установить переменные среды
--env-file list- Чтение в файле переменных среды
Хороший способ перехватить переменные среды хоста и вставить их в контейнер:

$ env | grep AWS_
AWS_REGION=eu-west-1
AWS_SES_SECRET_KEY=***
AWS_SES_KEY=***

$ docker run -it -e AWS_REGION centos env | grep AWS_
AWS_REGION=eu-west-1

$ docker run -it --env-file <(env| grep AWS_ | cut -f1 -d=) centos env | grep AWS_
AWS_REGION=eu-west-1
AWS_SES_SECRET_KEY=***
AWS_SES_KEY=***

=====================================================================
# Проверка состояния контейнера в Dockerfile

В распределенной системе доступность службы часто проверяется с помощью проверки работоспособности, чтобы избежать исключений при вызове других служб. Docker представил встроенную реализацию проверки работоспособности после версии 1.12.

Проверка работоспособности на уровне процесса проверяет, активен ли процесс, и является простейшей проверкой работоспособности контейнеров. Демон Docker автоматически отслеживает процесс PID1 в контейнере. Если команда запуска docker указывает политику перезапуска, закрытые контейнеры могут быть перезапущены автоматически в соответствии с политикой перезапуска. Во многих реальных сценариях одной только проверки работоспособности на уровне процесса недостаточно. Например, если процесс контейнера все еще активен, но заблокирован из-за взаимоблокировки приложения и не отвечает на запросы пользователя, такие проблемы не будут обнаружены при мониторинге процесса.

Один из подходов к настройке проверки работоспособности — напрямую указать политику проверки работоспособности в команде запуска docker:

$ docker run --rm -d \
    --name=elasticsearch \
    --health-cmd="curl --silent --fail localhost:9200/_cluster/health || exit 1" \
    --health-interval=5s \
    --health-retries=12 \
    --health-timeout=2s \
    elasticsearch:5.5
Docker выполняет команду HealthCheck внутри проверяемого контейнера.
Представьте, что у нас есть контейнер, в котором живёт веб-сервер, способность отвечать на запросы которого мы хотим проконтролировать. Например, раз в 5 секунд мы будем отправлять ему запрос, давать максимум 10 секунд на то, чтобы тот ответил, и если 3 раза подряд он слажает — будем подозревать неладное. Так как в Dockerfile есть инструкция HEALTHCHECK, и её формат — прост до безобразия (  HEALTHCHECK [OPTIONS] CMD command), то при помощи какого-нибудь curl нашу проверку можно сделать так:

FROM ...
...
HEALTHCHECK --interval=5s --timeout=10s --retries=3 CMD curl -sS 127.0.0.1 || exit 1
...

FROM ...
...
HEALTHCHECK --interval=5s --timeout=10s --retries=3 CMD curl -sS 127.0.0.1 || exit 1
...
Команда будет запускаться изнутри контейнера, так что обращаться к серверу можно и по 127.0.0.1.

Проверка состояния в docker-compose YAML
Она практически никак не отличается от оной в Dockerfile:

...
healthcheck:
  test: curl -sS http://127.0.0.1 || exit 1
  interval: 5s
  timeout: 10s
  retries: 3
...

...
healthcheck:
  test: curl -sS http://127.0.0.1 || exit 1
  interval: 5s
  timeout: 10s
  retries: 3
...
Проверка в docker run и service create
У этих двух синтаксис проверок одинаковый и тоже предсказуемо понятный:

docker run --health-cmd='curl -sS http://127.0.0.1 || exit 1' \
    --health-timeout=10s \
    --health-retries=3 \
    --health-interval=5s \
    ....

docker run --health-cmd='curl -sS http://127.0.0.1 || exit 1' \
    --health-timeout=10s \
    --health-retries=3 \
    --health-interval=5s \
    ....
Кстати, если в Dockerfile образе, который мы запускаем, уже была проверка, то на этой стадии её можно переопределить или даже выключить с помощью --no-healthcheck=true.










